---
title: "GNU Make for Reproducible Research"
subtitle: "Automating and Documenting Data Analysis Pipelines"
author: "UBC BIOF Statistics Workshop"
format:
  revealjs:
    theme: simple
    slide-number: true
    transition: slide
    navigation-mode: linear
    embed-resources: true
    width: 1280
    height: 720
    controls: true
    progress: true
    center: true
    code-line-numbers: false
    output-file: index.html # If naming other files , gh complains
---

## Welcome! üëã

**Today's Goal:**

Learn how to automate data analysis pipelines with GNU Make

. . .

**Who is this for?**

- Researchers doing multi-step data analysis
- Anyone tired of manually running scripts in order
- People who want reproducible research workflows

. . .

**What you'll learn:**

- Why automation matters for research
- How Make tracks dependencies automatically
- Building a real data analysis pipeline

---

## Installing GNU Make on Windows ü™ü

**Option 1: Using Chocolatey (Recommended)**

1. **Install Chocolatey** (if not already installed):
   - Right-click Start menu ‚Üí "Windows PowerShell (Admin)"
   - Visit: <https://chocolatey.org/install>
   - Copy and run the installation command from the website

2. **Install GNU Make:**
   ```powershell
   choco install make
   ```

3. **Verify installation:**
   ```bash
   make --version
   # Should show: GNU Make 4.x
   ```

. . .

**Option 2: Using Git for Windows (Built-in)**

- Download and install **Git for Windows**: <https://gitforwindows.org/>
- Make is included! Access via **Git Bash** terminal
- Look for "Git Bash" in your Start menu

. . .

**Troubleshooting:**
- If `make` command not found ‚Üí Restart terminal/PowerShell
- Use Git Bash instead of Command Prompt for Option 2

---

## Installing GNU Make on macOS üçé

**Option 1: Using Homebrew (Recommended)**

1. **Install Homebrew** (if not already installed):
   - Open **Terminal** (Applications ‚Üí Utilities ‚Üí Terminal)
   - Visit: <https://brew.sh/>
   - Copy and run the installation command:
   ```bash
   /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
   ```

2. **Install GNU Make:**
   ```bash
   brew install make
   ```

3. **Verify installation:**
   ```bash
   make --version
   # Should show: GNU Make 4.x
   ```

. . .

**Option 2: Xcode Command Line Tools (Built-in)**

GNU Make comes with Xcode Command Line Tools:
```bash
xcode-select --install
```
Click "Install" in the popup window

. . .

**Troubleshooting:**
- If `make --version` shows older version ‚Üí Use `brew install make`
- Homebrew installs as `gmake` on some systems ‚Üí Create alias or use `gmake`

---

## A Typical Research Pipeline

You have a multi-step data analysis:

```bash
# Step 1: Download data
Rscript download_data.R

# Step 2: Clean the data
Rscript clean_data.R

# Step 3: Run analysis
Rscript analyze.R

# Step 4: Make figures
Rscript make_figures.R
```

. . .

**You run all four scripts. Analysis complete!** ‚úÖ

---

## Then You Update Your Analysis Script...

You realize you need to fix a bug in `analyze.R`

. . .

**Question: Which scripts need to be re-run?**

. . .

A. Just `analyze.R`
B. `analyze.R` and `make_figures.R`
C. All four scripts
D. Not sure... better run them all!

---

## The Problem: Dependency Tracking

**After fixing `analyze.R`, you must:**

1. Re-run `analyze.R` (it changed)
2. Re-run `make_figures.R` (depends on `analyze.R` output)
3. Skip `download_data.R` and `clean_data.R` (inputs unchanged)

. . .

**But how do you remember this?**

‚ùå Keep dependencies in your head (error-prone!)
‚ùå Re-run everything every time (slow!)
‚ùå Write them down somewhere (tedious!)

---

## The Problem Gets Worse

**Real research pipelines have:**

- 10+ scripts running in sequence
- Complex dependencies (script C needs outputs from A and B)
- Long-running steps (some take hours!)
- Multiple researchers working on different parts

. . .

**What happens when you update the raw data?**

You need to re-run EVERYTHING downstream... but which scripts are those?

. . .

‚úÖ **Solution: GNU Make automatically tracks all dependencies!**

---

## What is GNU Make? üîß

**A build automation tool that:**

. . .

1. **Knows about dependencies** between your files
2. **Runs only what's outdated** when files change
3. **Documents your entire workflow** in one Makefile
4. **Ensures reproducibility**

. . .

Originally created for compiling software, but perfect for data pipelines!

. . .

**Think of Make as:**
A smart assistant that remembers which scripts depend on which files

---

## Why Make for Data Analysis?

**Shell script limitations:**

```bash
#!/bin/bash
# run_all.sh - runs EVERYTHING every time
Rscript download.R   # 5 minutes
Rscript clean.R      # 10 minutes
Rscript analyze.R    # 30 minutes
Rscript plot.R       # 2 minutes
# Total: 47 minutes every run!
```

. . .

**Makefile advantages:**

- Only re-runs what changed (edit plot.R ‚Üí 2 min rerun!)
- Automatic dependency tracking
- Self-documenting workflow
- Can run independent tasks in parallel

---

## A Makefile Documents Your Pipeline

Instead of keeping track in your head:

. . .

**Makefile explicitly states:**

- `clean_data.csv` needs `raw_data.csv`
- `results.txt` needs `clean_data.csv`
- `plot.png` needs `results.txt`

. . .

If you change `raw_data.csv`, Make knows to rebuild:
- `clean_data.csv` (directly depends on raw data)
- `results.txt` (depends on clean data)
- `plot.png` (depends on results)

. . .

**This is documented, automated, and always correct!**

---

## Basic Makefile Syntax

**A rule has three parts:**

```makefile
target: dependencies
	command
```

. . .

**Real example:**

```makefile
clean_data.csv: raw_data.csv
	Rscript clean_data.R
```

. . .

- **target** = file you want to create (`clean_data.csv`)
- **dependencies** = files needed to create it (`raw_data.csv`)
- **command** = how to create it (`Rscript clean_data.R`)

. . .

**‚ö†Ô∏è IMPORTANT:** Commands MUST start with a TAB character, not spaces!

---

## How Make Decides What to Run

When you run `make clean_data.csv`:

. . .

**Make asks three questions:**

1. Does `clean_data.csv` exist?
   - No ‚Üí Run the command
   - Yes ‚Üí Go to question 2

. . .

2. Does `raw_data.csv` exist?
   - No ‚Üí Error: can't build target
   - Yes ‚Üí Go to question 3

. . .

3. Is `raw_data.csv` newer than `clean_data.csv`?
   - Yes ‚Üí Run the command (rebuild needed)
   - No ‚Üí Skip! Target is up to date

. . .

**This is the magic! Make uses file timestamps to track what's outdated**

---

## Real Example: Let's Build a Pipeline!

**Our analysis workflow:**

1. Download iris dataset from web
2. Clean and filter the data
3. Run statistical analysis
4. Generate visualization

. . .

**We'll build this step-by-step in a Makefile**

Let's see how Make handles the dependencies automatically!

---

## Step 1: Download the Data

**First rule in our `Makefile`:**

```makefile
data/raw_data.csv:
	mkdir -p data
	wget -O data/raw_data.csv \
	  https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv
```

. . .

**Run it:**

```bash
make data/raw_data.csv
# Creates directory and downloads file
```

. . .

**Run it again:**

```bash
make data/raw_data.csv
# make: 'data/raw_data.csv' is up to date.
# Nothing to do!
```

---

## Step 2: Clean the Data

**Add a second rule:**

```makefile
data/clean_data.csv: data/raw_data.csv scripts/clean.R
	Rscript scripts/clean.R
```

. . .

**This rule says:**
- To create `clean_data.csv`, you need TWO things:
  - `raw_data.csv` (the data)
  - `clean.R` (the script)
- If either changes, re-run the cleaning script

. . .

**Try it:**
- Edit `scripts/clean.R`
- Run `make data/clean_data.csv`
- Make sees `clean.R` changed ‚Üí rebuilds `clean_data.csv`!

---

## Step 3: Statistical Analysis

**Add another rule:**

```makefile
results/statistics.txt: data/clean_data.csv scripts/analyze.R
	mkdir -p results
	Rscript scripts/analyze.R
```

. . .

**Now we have a chain:**

```
raw_data.csv ‚Üí clean_data.csv ‚Üí statistics.txt
```

. . .

**Make automatically follows the chain!**
- If you change `raw_data.csv`
- Make rebuilds `clean_data.csv` (depends on raw data)
- Then rebuilds `statistics.txt` (depends on clean data)

---

## Step 4: Make Figures

**Final rule:**

```makefile
figures/plot.png: results/statistics.txt scripts/plot.R
	mkdir -p figures
	Rscript scripts/plot.R
```

. . .

**Complete pipeline:**

```
raw_data.csv ‚Üí clean_data.csv ‚Üí statistics.txt ‚Üí plot.png
```

. . .

**To run the entire pipeline:**

```bash
make figures/plot.png
```

Make builds each dependency in order automatically!

---

## Your Complete First Makefile

```makefile
# Download data
data/raw_data.csv:
	mkdir -p data
	wget -O data/raw_data.csv \
	  https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv

# Clean data
data/clean_data.csv: data/raw_data.csv scripts/clean.R
	Rscript scripts/clean.R

# Analyze
results/statistics.txt: data/clean_data.csv scripts/analyze.R
	mkdir -p results
	Rscript scripts/analyze.R

# Create figure
figures/plot.png: results/statistics.txt scripts/plot.R
	mkdir -p figures
	Rscript scripts/plot.R
```

---

## Testing Your Pipeline

**Run the full pipeline:**

```bash
make figures/plot.png
```

. . .

Make will execute in order:
1. Download `raw_data.csv` (if missing)
2. Create `clean_data.csv` (if raw data exists)
3. Generate `statistics.txt` (if clean data exists)
4. Build `plot.png` (if statistics exist)

. . .

**Run it again immediately:**

```bash
make figures/plot.png
# make: 'figures/plot.png' is up to date.
```

. . .

**Edit `scripts/plot.R` and run again:**

Only re-runs the plotting step! (seconds instead of minutes)

---

## Phony Targets: Special Rules

Some targets don't create actual files:

```makefile
.PHONY: all clean

all: figures/plot.png

clean:
	rm -f data/clean_data.csv
	rm -f results/statistics.txt
	rm -f figures/plot.png
```

. . .

**`.PHONY`** tells Make these aren't real files

. . .

**Usage:**

```bash
make all    # Build the final output
make clean  # Remove generated files, start fresh
```

. . .

**Why `.PHONY`?**
Without it, if a file named "clean" exists, `make clean` won't run!

---

## Making Makefiles Readable with Variables

**Instead of repeating paths:**

```makefile
# Define variables at the top
DATA_DIR = data
SCRIPTS = scripts
RESULTS = results
FIGURES = figures

# Use variables in rules
$(DATA_DIR)/clean_data.csv: $(DATA_DIR)/raw_data.csv $(SCRIPTS)/clean.R
	Rscript $(SCRIPTS)/clean.R

$(FIGURES)/plot.png: $(RESULTS)/statistics.txt $(SCRIPTS)/plot.R
	mkdir -p $(FIGURES)
	Rscript $(SCRIPTS)/plot.R
```

. . .

**Benefits:**
- Change paths in one place
- Easier to read and maintain
- Less prone to typos

---

## Pattern Rules: DRY Principle

**Problem:** Converting many CSV files to Excel format

**Without pattern rules (repetitive!):**

```makefile
results/table1.xlsx: results/table1.csv
	python convert.py results/table1.csv results/table1.xlsx

results/table2.xlsx: results/table2.csv
	python convert.py results/table2.csv results/table2.xlsx

results/table3.xlsx: results/table3.csv
	python convert.py results/table3.csv results/table3.xlsx
```

. . .

**With pattern rules (elegant!):**

```makefile
%.xlsx: %.csv
	python convert.py $< $@
```

This one rule handles ALL csv ‚Üí xlsx conversions!

---

## Pattern Rule Syntax

```makefile
%.xlsx: %.csv
	python convert.py $< $@
```

. . .

**Breaking it down:**

- `%` = wildcard matching any string
- `%.xlsx` = target pattern (e.g., `table1.xlsx`, `table2.xlsx`)
- `%.csv` = dependency pattern (e.g., `table1.csv`, `table2.csv`)

. . .

**Automatic variables:**

- `$<` = first dependency (the `.csv` file)
- `$@` = target (the `.xlsx` file)

. . .

**Example:** For `results/table1.xlsx`:
- `$<` expands to `results/table1.csv`
- `$@` expands to `results/table1.xlsx`

---

## Putting It All Together

**A complete, well-organized Makefile:**

```makefile
.PHONY: all clean

# Variables
DATA = data
RESULTS = results
FIGURES = figures

# Default target
all: $(FIGURES)/iris_plot.png

# Pipeline rules
$(DATA)/iris.csv:
	mkdir -p $(DATA)
	wget -O $@ \
	  https://raw.githubusercontent.com/mwaskom/seaborn-data/master/iris.csv

$(DATA)/iris_clean.csv: $(DATA)/iris.csv scripts/clean.R
	Rscript scripts/clean.R

$(RESULTS)/model_summary.txt: $(DATA)/iris_clean.csv scripts/analyze.R
	mkdir -p $(RESULTS)
	Rscript scripts/analyze.R

$(FIGURES)/iris_plot.png: $(RESULTS)/model_summary.txt scripts/plot.R
	mkdir -p $(FIGURES)
	Rscript scripts/plot.R

# Cleanup
clean:
	rm -rf $(DATA) $(RESULTS) $(FIGURES)
```

---

## Parallel Execution (Bonus)

If you have independent tasks, Make can run them simultaneously:

```makefile
all: figure1.png figure2.png figure3.png

figure1.png: data.csv script1.R
	Rscript script1.R

figure2.png: data.csv script2.R
	Rscript script2.R

figure3.png: data.csv script3.R
	Rscript script3.R
```

**Run in parallel:**

```bash
make -j 3 all  # Run up to 3 jobs at once
```

Great for speeding up independent analyses!

---

## When Should You Use Make?

**‚úÖ Use Make when:**

- Multi-step pipeline (download ‚Üí clean ‚Üí analyze ‚Üí visualize)
- Long-running computations (don't want to rerun everything)
- Multiple tools involved (R + Python + shell scripts)
- Team collaboration (document the workflow clearly)

. . .

**üìù Stick with simple R scripts when:**

- Single analysis that fits in one script
- Very quick computations (seconds)
- No intermediate files to track

---

## Best Practices

1. **One Makefile per project** in the root directory
2. **Use meaningful target names** (not `temp1.csv`)
3. **Comment your Makefile** to explain steps
4. **Use variables** for paths and commands
5. **Add `.PHONY`** for non-file targets
6. **Test incrementally** as you build your Makefile

---

## Common Pitfalls to Avoid

**‚ùå Tabs vs Spaces**

```makefile
target: dependency
    command  # WRONG! These are spaces
	command  # RIGHT! This is a TAB character
```

Set your text editor to show whitespace characters!

. . .

**‚ùå Circular Dependencies**

```makefile
a.txt: b.txt
	process b.txt > a.txt

b.txt: a.txt  # ERROR: Can't have both depend on each other!
	process a.txt > b.txt
```

. . .

**‚ùå Forgetting `.PHONY`**

If you have a file named "clean", `make clean` won't work without `.PHONY: clean`

---

## Debugging Your Makefile

**See what Make would do (without running):**

```bash
make -n target  # "Dry run" - prints commands only
```

. . .

**Understand why Make rebuilds something:**

```bash
make -d target  # Debug mode with verbose output
```

. . .

**Force a complete rebuild:**

```bash
make -B target  # Rebuild everything, ignore timestamps
```

. . .

**Pro tip:** Start with `make -n` to check your Makefile logic before running expensive computations!

---

## Resources and References

**Official Documentation:**

- [GNU Make Manual](https://www.gnu.org/software/make/manual/)
- [Make Tutorial](https://makefiletutorial.com/)

. . .

**This workshop is based on:**

- [STAT 545 Automating Data-analysis Pipelines](https://github.com/STAT545-UBC/STAT545-UBC-original-website/blob/master/automation01_slides/slides.md) by Shaun Jackman & Jenny Bryan
- [Software Carpentry: Automation and Make](https://swcarpentry.github.io/make-novice/)

. . .

**Further Reading:**

- [Minimal Make](https://kbroman.org/minimal_make/) by Karl Broman
- [Why Use Make](https://bost.ocks.org/mike/make/) by Mike Bostock

---

## Key Takeaways

**Remember these core concepts:**

. . .

‚úÖ Make **tracks dependencies** between files automatically

. . .

‚úÖ Make **only rebuilds what changed** (massive time savings!)

. . .

‚úÖ Makefiles **document your entire workflow** in one place

. . .

‚úÖ Works with **any tools** (R, Python, shell scripts, etc.)

. . .

‚úÖ **Essential for reproducible research** workflows

---

## Your Next Steps

**Starting your first Makefile:**

1. **Pick a current project** with 2-3 scripts
2. **Start simple**: Just add rules for your main outputs
3. **Test each rule** as you add it (`make -n` first!)
4. **Build incrementally**: Add variables and `.PHONY` targets
5. **Iterate**: Refine as you learn what works

. . .

**Remember:** Even a simple Makefile is better than none!

. . .

You don't need to be an expert to benefit from Make

---

## Questions? ü§î

**Thank you for attending!**

. . .

**Key message:**
Make = Your research pipeline's documentation + automation

. . .

Think of your Makefile as a **lab notebook for computational work**

. . .

Start using Make in your next project! üöÄ
